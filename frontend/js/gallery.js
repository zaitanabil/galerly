// Photo Modal Functionality - Simplified and Fluid
// Uses config.js for API configuration
// Photos are loaded dynamically by gallery-loader.js
let currentPhotoIndex = 0;

// Image preloading cache for instant navigation (same as client-gallery.js)
const imageCache = new Map();
const preloadQueue = [];
let isPreloading = false;

/**
 * Aggressive preloader: Preload current, next, and previous images
 */
function preloadImages(centerIndex) {
    const photos = window.galleryPhotos || [];
    if (!photos.length) return;
    
    // Preload current, next 2, and previous 2 images (5 total)
    const indicesToPreload = [
        centerIndex,
        (centerIndex + 1) % photos.length,
        (centerIndex + 2) % photos.length,
        (centerIndex - 1 + photos.length) % photos.length,
        (centerIndex - 2 + photos.length) % photos.length
    ];
    
    indicesToPreload.forEach((index, priority) => {
        const photo = photos[index];
        if (!photo) return;
        
        // Preload medium-res rendition (pre-generated by backend)
        const mediumUrl = getImageUrl(photo.medium_url || photo.url);
        if (imageCache.has(mediumUrl)) return;
        
        preloadQueue.push({ url: mediumUrl, priority });
    });
    
    if (!isPreloading) processPreloadQueue();
}

/**
 * Process preload queue in priority order
 */
function processPreloadQueue() {
    if (preloadQueue.length === 0) {
        isPreloading = false;
        return;
    }
    
    isPreloading = true;
    preloadQueue.sort((a, b) => a.priority - b.priority);
    const batch = preloadQueue.splice(0, 3);
    
    const promises = batch.map(item => {
        return new Promise((resolve) => {
            if (imageCache.has(item.url)) {
                resolve();
                return;
            }
            
            const img = new Image();
            img.onload = () => {
                imageCache.set(item.url, img);
                resolve();
            };
            img.onerror = () => resolve();
            img.src = item.url;
        });
    });
    
    Promise.all(promises).then(() => {
        if (preloadQueue.length > 0) {
            processPreloadQueue();
        } else {
            isPreloading = false;
        }
    });
}

function openPhotoModal(index) {
    currentPhotoIndex = index;
    const modal = document.getElementById('photoModal');
    const modalImage = document.getElementById('modalImage');
    // Use dynamically loaded photos from gallery-loader.js
    const photos = window.galleryPhotos || [];
    if (!photos[index]) {
        console.error('Photo not found at index:', index);
        return;
    }
    const photo = photos[index];
    // Use pre-generated medium-res rendition for viewing
    // Original file used only for downloads
    const mediumUrl = getImageUrl(photo.medium_url || photo.url);
    const thumbUrl = getImageUrl(photo.thumbnail_url || photo.url);
    
    // Show thumbnail immediately for instant feedback
    modalImage.src = thumbUrl;
    modalImage.style.filter = 'blur(5px)';
    modalImage.style.transition = 'filter 0.3s ease';
    
    // Load medium-res (from cache if available)
    if (imageCache.has(mediumUrl)) {
        modalImage.src = imageCache.get(mediumUrl).src;
        modalImage.style.filter = 'none';
    } else {
        const mediumImg = new Image();
        mediumImg.onload = () => {
            imageCache.set(mediumUrl, mediumImg);
            modalImage.src = mediumUrl;
            modalImage.style.filter = 'none';
        };
        mediumImg.onerror = () => {
            console.warn('⚠️  Medium rendition failed, using original:', photo.url);
            // Fallback to original if medium fails
            const originalUrl = getImageUrl(photo.url);
            const originalImg = new Image();
            originalImg.onload = () => {
                imageCache.set(mediumUrl, originalImg); // Cache under medium URL
                modalImage.src = originalUrl;
                modalImage.style.filter = 'none';
            };
            originalImg.onerror = () => {
                console.error('❌ Both medium and original failed for photo:', photo.id);
                modalImage.style.filter = 'none';
                modalImage.alt = 'Failed to load image';
            };
            originalImg.src = originalUrl;
        };
        mediumImg.src = mediumUrl;
    }
    
    updateModalContent();
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';
    
    // Aggressively preload adjacent images
    preloadImages(index);
    
    // Track photo view (analytics) - backend will skip if viewer is the owner
    // Always track (backend handles owner check)
    if (typeof window.trackPhotoView === 'function' && window.currentGalleryId) {
        try {
            window.trackPhotoView(photo.id, window.currentGalleryId, {
                ip: '', // Will be set by backend if needed
                user_agent: navigator.userAgent
            });
        } catch (err) {
        }
    }
}
function closePhotoModal() {
    const modal = document.getElementById('photoModal');
    modal.classList.remove('active');
    document.body.style.overflow = '';
    // Stop polling when modal closes
    if (typeof window.stopCommentsPolling === 'function') {
        window.stopCommentsPolling();
    }
}
function navigatePhoto(direction) {
    const photos = window.galleryPhotos || [];
    currentPhotoIndex += direction;
    if (currentPhotoIndex < 0) currentPhotoIndex = photos.length - 1;
    if (currentPhotoIndex >= photos.length) currentPhotoIndex = 0;
    // Stop polling for previous photo
    if (typeof window.stopCommentsPolling === 'function') {
        window.stopCommentsPolling();
    }
    const modalImage = document.getElementById('modalImage');
    const photo = photos[currentPhotoIndex];
    const mediumUrl = getImageUrl(photo.medium_url || photo.url);
    const thumbUrl = getImageUrl(photo.thumbnail_url || photo.url);
    
    // Show cached medium-res instantly
    if (imageCache.has(mediumUrl)) {
        modalImage.src = imageCache.get(mediumUrl).src;
        modalImage.style.filter = 'none';
    } else {
        modalImage.src = thumbUrl;
        modalImage.style.filter = 'blur(5px)';
        modalImage.style.transition = 'filter 0.3s ease';
        
        const mediumImg = new Image();
        mediumImg.onload = () => {
            imageCache.set(mediumUrl, mediumImg);
            modalImage.src = mediumUrl;
            modalImage.style.filter = 'none';
        };
        mediumImg.onerror = () => {
            console.warn('⚠️  Medium rendition failed during navigation, using original');
            // Fallback to original
            const originalUrl = getImageUrl(photo.url);
            const originalImg = new Image();
            originalImg.onload = () => {
                imageCache.set(mediumUrl, originalImg);
                modalImage.src = originalUrl;
                modalImage.style.filter = 'none';
            };
            originalImg.onerror = () => {
                console.error('❌ Original also failed for photo:', photo.id);
                modalImage.style.filter = 'none';
            };
            originalImg.src = originalUrl;
        };
        mediumImg.src = mediumUrl;
    }
    
    updateModalContent();
    preloadImages(currentPhotoIndex);
}
function updateModalContent() {
    const photos = window.galleryPhotos || [];
    const data = photos[currentPhotoIndex] || { status: 'pending', comments: [] };
    const statusIndicator = document.getElementById('statusIndicator');
    const actionButtons = document.getElementById('actionButtonsSimple');
    const photoNumber = document.getElementById('photoNumber');
    const commentsList = document.getElementById('commentsList');
    // Update status indicator
    statusIndicator.className = `status-indicator ${data.status}`;
    
    // Map status to display text
    let statusText = 'Ready for Review';
    if (data.status === 'pending') {
        statusText = 'Pending';
    } else if (data.status === 'approved') {
        statusText = 'Approved by Client';
    } else if (data.status === 'active') {
        statusText = 'Ready for Review';
    } else if (data.status === 'processing') {
        statusText = 'Processing...';
    }
    
    statusIndicator.querySelector('span:last-child').textContent = statusText;
    // Update photo number
    photoNumber.textContent = `Photo ${currentPhotoIndex + 1} of ${photos.length}`;
    // Apply gallery permissions FIRST (this shows/hides download button)
    applyGalleryPermissions();
    // Hide APPROVE button for photographers (only clients can approve)
    // Photographers view their own galleries, so they should never see approve button
    const approveBtn = actionButtons.querySelector('.approve');
        if (approveBtn) {
        approveBtn.style.display = 'none';  // Always hide for photographers
        }
    // Show/hide action bar based on available buttons
        const downloadBtn = document.getElementById('downloadPhotoBtn');
        if (downloadBtn && downloadBtn.style.display !== 'none') {
        actionButtons.style.display = 'flex';
    } else {
        actionButtons.style.display = 'none';
    }
    // Load comments for THIS photo using enhanced system
    loadPhotoComments();
}
function loadPhotoComments() {
    const photos = window.galleryPhotos || [];
    const photo = photos[currentPhotoIndex];
    if (!photo || !photo.id) return;
    // Get current user and gallery info for permissions
    const currentUser = getUserData();
    const currentUserId = currentUser ? currentUser.id : null;
    const gallery = window.currentGalleryData || {};
    const isGalleryOwner = currentUserId === gallery.user_id;
    // Use enhanced comments rendering if available, otherwise fallback to simple
    if (typeof window.renderEnhancedComments === 'function') {
        window.renderEnhancedComments(photo.comments || [], photo.id, currentUserId, isGalleryOwner);
    } else {
        // Fallback to simple rendering
        const commentsList = document.getElementById('commentsList');
        if (!commentsList) return;
        commentsList.innerHTML = '';
    const comments = photo?.comments || [];
    if (comments.length === 0) {
        commentsList.innerHTML = '<p style="text-align: center; opacity: 0.5; padding: 40px 20px;">No comments yet. Be the first to comment!</p>';
        return;
    }
        comments.forEach(comment => {
        const commentEl = document.createElement('div');
        commentEl.className = 'comment-item-simple';
        commentEl.innerHTML = `
            <div class="comment-header">
                    <span class="comment-author-simple">${escapeHtml(comment.author || 'Anonymous')}</span>
                <span class="comment-time-simple">${formatCommentTime(comment.created_at)}</span>
            </div>
            <p class="comment-text-simple">${escapeHtml(comment.text)}</p>
        `;
        commentsList.appendChild(commentEl);
    });
    }
}
function formatCommentTime(timestamp) {
    if (!timestamp) return 'Just now';
    try {
        // Parse the ISO timestamp (backend sends UTC)
        const date = new Date(timestamp);
        const now = new Date();
        // Calculate difference in milliseconds
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        // Handle future dates (clock skew)
        if (diffMs < 0) return 'Just now';
        // Format time difference
        if (diffMins < 1) return 'Just now';
        if (diffMins === 1) return '1 minute ago';
        if (diffMins < 60) return `${diffMins} minutes ago`;
        if (diffHours === 1) return '1 hour ago';
        if (diffHours < 24) return `${diffHours} hours ago`;
        if (diffDays === 1) return '1 day ago';
        if (diffDays < 7) return `${diffDays} days ago`;
        // For older dates, show the actual date
        return date.toLocaleDateString(undefined, { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
        });
    } catch (e) {
        console.error('Error formatting time:', e);
        return 'Just now';
    }
}
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
async function approvePhoto() {
    const photos = window.galleryPhotos || [];
    const photoId = photos[currentPhotoIndex]?.id;
    if (!photoId) {
        console.error('No photo ID found');
        return;
    }
    try {
        await apiRequest(`photos/${photoId}`, {
            method: 'PUT',
            body: JSON.stringify({ status: 'approved' })
        });
        // Update local data
        photos[currentPhotoIndex].status = 'approved';
        updateModalContent();
        // Show success animation
        const statusIndicator = document.getElementById('statusIndicator');
        statusIndicator.style.transition = 'all 0.5s ease';
        statusIndicator.style.transform = 'scale(1.1)';
        setTimeout(() => {
            statusIndicator.style.transform = 'scale(1)';
        }, 500);
        // Reload gallery to update main grid
        if (window.loadGalleryData) {
            await window.loadGalleryData();
        }
    } catch (error) {
        console.error('Error approving photo:', error);
        alert('Failed to approve photo. Please try again.');
    }
}
function focusComment() {
    const commentInput = document.getElementById('commentInput');
    commentInput.focus();
    commentInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
}
async function addComment() {
    const commentInput = document.getElementById('commentInput');
    const commentText = commentInput.value.trim();
    if (!commentText) return;
    const photos = window.galleryPhotos || [];
    const photo = photos[currentPhotoIndex];
    if (!photo || !photo.id) {
        console.error('No photo ID found');
        return;
    }
    // Show loading state
    const originalPlaceholder = commentInput.placeholder;
    commentInput.placeholder = 'Posting comment...';
    commentInput.disabled = true;
    try {
        // Use enhanced comment system if available, otherwise use simple
        if (typeof window.addEnhancedComment === 'function') {
            await window.addEnhancedComment(photo.id, commentText, null);
        } else {
            // Fallback to simple comment system
        const response = await apiRequest(`photos/${photo.id}/comments`, {
            method: 'POST',
            body: JSON.stringify({
                    text: commentText
            })
        });
        if (!photo.comments) {
            photo.comments = [];
        }
            photo.comments.push(response);
        }
        // Clear input
        commentInput.value = '';
        commentInput.placeholder = originalPlaceholder;
        commentInput.disabled = false;
        // Reload comments to show the new one
        loadPhotoComments();
        // Show success notification
        if (typeof window.showNotification === 'function') {
            window.showNotification('Comment added successfully!');
        } else {
        showNotification('Comment added successfully!');
        }
    } catch (error) {
        console.error('Error adding comment:', error);
        commentInput.placeholder = originalPlaceholder;
        commentInput.disabled = false;
        const errorMsg = error.details?.message || error.message || 'Failed to add comment. Please try again.';
        alert(errorMsg);
    }
}
function showNotification(message) {
    // Simple notification (you can enhance this later)
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: #4CAF50;
        color: white;
        padding: 14px 28px;
        border-radius: 999px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        animation: slideInRight 0.3s ease;
        white-space: nowrap;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => {
        notification.style.animation = 'slideOutRight 0.3s ease';
        setTimeout(() => notification.remove(), 300);
    }, 2000);
}
// Keyboard navigation
document.addEventListener('keydown', function(e) {
    const modal = document.getElementById('photoModal');
    if (!modal.classList.contains('active')) return;
    // Don't navigate photos if user is typing in an input/textarea
    const activeElement = document.activeElement;
    const isTyping = activeElement && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.isContentEditable
    );
    if (isTyping) return; // Let the user type normally
    if (e.key === 'Escape') closePhotoModal();
    if (e.key === 'ArrowLeft') navigatePhoto(-1);
    if (e.key === 'ArrowRight') navigatePhoto(1);
});
// Close modal when clicking on background
document.getElementById('photoModal').addEventListener('click', function(e) {
    if (e.target === this) closePhotoModal();
});
// ===== SETTINGS MODAL FUNCTIONALITY =====
// Global array to store client emails
let clientEmails = [];
/**
 * Add a new client email to the list
 */
function addClientEmail() {
    const input = document.getElementById('newClientEmail');
    const email = input.value.trim().toLowerCase();
    // Validate email
    if (!email) {
        return; // Silently ignore empty input
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        alert('Please enter a valid email address');
        input.focus();
        return;
    }
    // Check for duplicates
    if (clientEmails.includes(email)) {
        alert('This email is already added');
        input.value = '';
        input.focus();
        return;
    }
    // Add to array
    clientEmails.push(email);
    // Clear input and focus for next entry
    input.value = '';
    input.focus();
    // Re-render list
    renderClientEmailsList();
    // Show brief success indicator
    input.style.borderColor = '#4CAF50';
    setTimeout(() => {
        input.style.borderColor = '';
    }, 500);
}
/**
 * Remove a client email from the list
 */
function removeClientEmail(email) {
    clientEmails = clientEmails.filter(e => e !== email);
    renderClientEmailsList();
}
/**
 * Render the list of client emails
 */
function renderClientEmailsList() {
    const container = document.getElementById('clientEmailsList');
    if (!container) return;
    if (clientEmails.length === 0) {
        container.innerHTML = '<p style="opacity: 0.6; font-size: 14px; padding: 12px 0; font-family: var(--pp-neue-font);">No clients added yet. Add client emails below to share this gallery.</p>';
        return;
    }
    container.innerHTML = clientEmails.map(email => `
        <div class="client-email-item" style="
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--background-secondary, #F5F5F7);
            border-radius: var(--border-radius-m, 8px);
            margin-bottom: 8px;
            animation: slideIn 0.2s ease-out;
        ">
            <span style="font-size: 14px; color: var(--text-primary); font-family: var(--pp-neue-font);">${escapeHtml(email)}</span>
            <button 
                type="button" 
                onclick="removeClientEmail('${email}')" 
                class="btn-text-danger"
                style="
                    background: none;
                    border: none;
                    color: var(--color-error, #FF3B30);
                    cursor: pointer;
                    padding: 6px 12px;
                    font-size: 13px;
                    font-family: var(--pp-neue-font);
                    font-weight: 500;
                    border-radius: 6px;
                    transition: background 0.2s;
                "
                onmouseover="this.style.background='rgba(255, 59, 48, 0.1)'"
                onmouseout="this.style.background='none'"
            >
                Remove
            </button>
        </div>
    `).join('');
}
/**
 * Handle Enter key press in client email input
 */
function handleClientEmailKeyPress(event) {
    if (event.key === 'Enter') {
        event.preventDefault(); // Prevent form submission
        addClientEmail();
    }
}
function openSettingsModal() {
    const modal = document.getElementById('settingsModal');
    modal.classList.add('active');
    document.body.style.overflow = 'hidden';
    // Load current gallery settings including client emails
    loadGallerySettings();
}
function closeSettingsModal() {
    const modal = document.getElementById('settingsModal');
    modal.classList.remove('active');
    document.body.style.overflow = '';
}
/**
 * Load gallery settings into the form
 * @param {Object} gallery - Optional gallery data object (if not provided, uses window.currentGalleryData)
 */
function loadGallerySettings(gallery) {
    // Use provided gallery or fallback to current gallery data
    const galleryData = gallery || window.currentGalleryData;
    if (!galleryData) return;
    const form = document.getElementById('settingsForm');
    if (!form) return;
    // Load basic settings
    form.querySelector('[name="galleryName"]').value = galleryData.name || '';
    form.querySelector('[name="clientName"]').value = galleryData.client_name || '';
    form.querySelector('[name="description"]').value = galleryData.description || '';
    // Load client emails
    if (galleryData.client_emails && Array.isArray(galleryData.client_emails)) {
        clientEmails = [...galleryData.client_emails];
    } else if (galleryData.client_email) {
        // Legacy: convert single email to array
        clientEmails = [galleryData.client_email];
    } else {
        clientEmails = [];
    }
    renderClientEmailsList();
    // Load checkboxes
    const allowDownloadsCheckbox = form.querySelector('[name="allowDownloads"]');
    if (allowDownloadsCheckbox) {
        allowDownloadsCheckbox.checked = galleryData.allow_downloads !== false;
    }
    const allowCommentsCheckbox = form.querySelector('[name="allowComments"]');
    if (allowCommentsCheckbox) {
        allowCommentsCheckbox.checked = galleryData.allow_comments !== false;
    }
}
// Handle settings form submission
document.getElementById('settingsForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    const galleryId = window.currentGalleryId || new URLSearchParams(window.location.search).get('id');
    if (!galleryId) {
        alert('Gallery ID not found. Please refresh the page.');
        return;
    }
    // Collect form data
    const formData = new FormData(e.target);
    const settings = {
        name: formData.get('galleryName'),
        client_name: formData.get('clientName'),
        clientEmails: clientEmails,  // Send array of client emails
        description: formData.get('description'),
        privacy: formData.get('privacy') === 'on' ? 'public' : 'private',  // Privacy toggle for portfolio
        allowDownloads: formData.get('allowDownloads') === 'on',  // Send as camelCase to match backend
        allowComments: formData.get('allowComments') === 'on',  // Send as camelCase to match backend
        expiry_days: parseInt(formData.get('expiry')) || null
    };
    // Show loading state
    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.querySelector('span').textContent;
    submitBtn.querySelector('span').textContent = 'Saving...';
    submitBtn.disabled = true;
    try {
        // Update gallery via API
        const updated = await apiRequest(`galleries/${galleryId}`, {
            method: 'PUT',
            body: JSON.stringify(settings)
        });
        // Update local gallery data
        if (window.currentGalleryData) {
            Object.assign(window.currentGalleryData, settings);
        }
        // Update page title and display
        document.title = `${settings.name} — Galerly`;
        // Update gallery header
        const galleryTitle = document.querySelector('.subtitle-14.nav-7');
        if (galleryTitle) {
            galleryTitle.textContent = settings.name.toUpperCase();
        }
        // Update description
        const descriptionTitle = document.getElementById('galleryDescriptionTitle');
        const descriptionText = document.getElementById('galleryDescriptionText');
        if (settings.description) {
            if (descriptionTitle) {
                descriptionTitle.textContent = settings.description;
            }
            if (descriptionText) {
                descriptionText.textContent = 'Edit this description in Gallery Settings to personalize your message for clients.';
            }
        } else {
            // No description - show helpful message
            if (descriptionTitle) {
                descriptionTitle.textContent = settings.name;
            }
            if (descriptionText) {
                descriptionText.textContent = 'Add a description in Gallery Settings to share details with your clients.';
            }
        }
        // Show success message
        showNotification('Settings saved successfully!');
        // Close modal after brief delay
        setTimeout(() => {
            closeSettingsModal();
            submitBtn.querySelector('span').textContent = originalText;
            submitBtn.disabled = false;
        }, 800);
    } catch (error) {
        console.error('❌ Error saving settings:', error);
        submitBtn.querySelector('span').textContent = originalText;
        submitBtn.disabled = false;
        alert('Failed to save settings. Please try again.');
    }
});
// Delete gallery function
async function deleteGallery() {
    const galleryId = window.currentGalleryId || new URLSearchParams(window.location.search).get('id');
    if (!galleryId) {
        alert('Gallery ID not found. Please refresh the page.');
        return;
    }
    const confirmed = confirm('⚠️ DELETE GALLERY?\n\nThis will permanently delete:\n• Gallery "' + (window.currentGalleryData?.name || 'this gallery') + '"\n• All uploaded photos\n• All comments\n• Share links\n\nThis action CANNOT be undone.\n\nType "DELETE" to confirm.');
    if (confirmed) {
        // Close settings modal first
        closeSettingsModal();
        // Show loading message
        const loadingDiv = document.createElement('div');
        loadingDiv.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px 60px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
            z-index: 10001;
            text-align: center;
        `;
        loadingDiv.innerHTML = `
            <div style="font-size: 18px; font-weight: 500; margin-bottom: 16px;">Deleting gallery...</div>
            <div style="font-size: 14px; opacity: 0.7;">Please wait</div>
        `;
        document.body.appendChild(loadingDiv);
        try {
            // Delete gallery via API
            await apiRequest(`galleries/${galleryId}`, {
                method: 'DELETE'
            });
            // Update loading message
            loadingDiv.innerHTML = `
                <div style="font-size: 18px; font-weight: 500; margin-bottom: 16px; color: #4CAF50;">✓ Gallery Deleted</div>
                <div style="font-size: 14px; opacity: 0.7;">Redirecting to dashboard...</div>
            `;
            // Redirect to dashboard after brief delay
            setTimeout(() => {
                window.location.href = 'dashboard';
            }, 1500);
        } catch (error) {
            console.error('❌ Error deleting gallery:', error);
            document.body.removeChild(loadingDiv);
            alert('Failed to delete gallery. Please try again.');
        }
    }
}
// Close modal when clicking on background
document.getElementById('settingsModal').addEventListener('click', function(e) {
    if (e.target === this) closeSettingsModal();
});
// Keyboard navigation for settings modal
document.addEventListener('keydown', function(e) {
    const modal = document.getElementById('settingsModal');
    if (modal.classList.contains('active') && e.key === 'Escape') {
        closeSettingsModal();
    }
});
// Share gallery from header
function shareGalleryFromHeader() {
    const urlParams = new URLSearchParams(window.location.search);
    const galleryId = urlParams.get('id');
    if (galleryId && typeof showGalleryShareModal === 'function') {
        showGalleryShareModal(galleryId, true); // authenticated = true
    } else {
        console.error('Gallery ID not found or sharing not available');
    }
}
// Share current photo from modal
function shareCurrentPhoto() {
    const photos = window.galleryPhotos || [];
    const photo = photos[currentPhotoIndex];
    if (photo && photo.id && typeof showPhotoShareModal === 'function') {
        showPhotoShareModal(photo.id, true); // authenticated = true
    } else {
        console.error('Photo not found or sharing not available');
    }
}
// Make functions globally available
window.shareGalleryFromHeader = shareGalleryFromHeader;
window.shareCurrentPhoto = shareCurrentPhoto;
// ===== GALLERY PERMISSIONS FUNCTIONALITY =====
/**
 * Apply gallery permissions to UI elements
 * Controls download button and comments based on gallery settings
 */
function applyGalleryPermissions() {
    const gallery = window.currentGalleryData;
    if (!gallery) {
        return;
    }
    // Handle download button
    const downloadBtn = document.getElementById('downloadPhotoBtn');
    if (downloadBtn) {
        if (gallery.allow_downloads) {
            downloadBtn.style.display = 'inline-block';
        } else {
            downloadBtn.style.display = 'none';
        }
    }
    // Handle comments section
    const commentsCard = document.getElementById('commentsCard');
    const commentInputWrapper = document.getElementById('commentInputWrapper');
    const commentsList = document.getElementById('commentsList');
    if (!gallery.allow_comments) {
        // Hide comment input
        if (commentInputWrapper) {
            commentInputWrapper.style.display = 'none';
        }
        // Show message that comments are disabled
        if (commentsList && commentsList.children.length === 0) {
            commentsList.innerHTML = '<p style="text-align: center; opacity: 0.5; padding: 40px 20px;">Comments have been disabled for this gallery.</p>';
        }
    } else {
        // Show comment input
        if (commentInputWrapper) {
            commentInputWrapper.style.display = 'block';
        }
    }
}
/**
 * Download current photo
 */
async function downloadPhoto() {
    const photos = window.galleryPhotos || [];
    const photo = photos[currentPhotoIndex];
    if (!photo) {
        console.error('No photo to download');
        return;
    }
    try {
        // Show loading notification
        const downloadBtn = document.getElementById('downloadPhotoBtn');
        const originalText = downloadBtn ? downloadBtn.textContent : 'Download';
        if (downloadBtn) {
            downloadBtn.textContent = 'Downloading...';
            downloadBtn.disabled = true;
        }
        // Get the image URL
        const imageUrl = getImageUrl(photo.url);
        // Fetch the image as a blob
        const response = await fetch(imageUrl);
        if (!response.ok) {
            throw new Error(`Failed to fetch image: ${response.status}`);
        }
        const blob = await response.blob();
        // Create a blob URL
        const blobUrl = URL.createObjectURL(blob);
        // Create a temporary anchor and trigger download
        const link = document.createElement('a');
        link.href = blobUrl;
        link.download = photo.filename || `galerly-photo-${Date.now()}.jpg`;
        // Trigger download
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        // Clean up the blob URL after download completes (longer delay for large files)
        setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
        // Restore button state
        if (downloadBtn) {
            downloadBtn.textContent = originalText;
            downloadBtn.disabled = false;
        }
        // Track photo download (analytics) - backend will skip if viewer is the owner
        // Always track (backend handles owner check)
        if (typeof window.trackPhotoDownload === 'function' && window.currentGalleryId) {
            try {
                window.trackPhotoDownload(photo.id, window.currentGalleryId, {
                    ip: '', // Will be set by backend if needed
                    user_agent: navigator.userAgent
                });
            } catch (err) {
            }
        }
        // Show success notification
        showNotification('Photo downloaded successfully!');
    } catch (error) {
        console.error('❌ Error downloading photo:', error);
        // Restore button state
        const downloadBtn = document.getElementById('downloadPhotoBtn');
        if (downloadBtn) {
            downloadBtn.textContent = 'Download';
            downloadBtn.disabled = false;
        }
        alert('Failed to download photo. Please try again.');
    }
}
// ===== EXPORT FUNCTIONS TO GLOBAL SCOPE =====
// These functions are called by inline onclick handlers in gallery
window.openPhotoModal = openPhotoModal;
window.closePhotoModal = closePhotoModal;
window.navigatePhoto = navigatePhoto;
window.approvePhoto = approvePhoto;
window.addComment = addComment;
window.downloadPhoto = downloadPhoto;
window.openSettingsModal = openSettingsModal;
window.closeSettingsModal = closeSettingsModal;
window.deleteGallery = deleteGallery;
window.addClientEmail = addClientEmail;
window.removeClientEmail = removeClientEmail;
window.handleClientEmailKeyPress = handleClientEmailKeyPress;
window.loadGallerySettings = loadGallerySettings;

// ===== BATCH EMAIL NOTIFICATION =====
/**
 * Send one batch email notification to all clients about new photos
 * Prevents clients from receiving 100 emails when 100 photos are uploaded
 */
async function sendBatchEmailNotification() {
    const galleryId = window.currentGalleryId || new URLSearchParams(window.location.search).get('id');
    if (!galleryId) {
        alert('Gallery ID not found. Please refresh the page.');
        return;
    }

    const gallery = window.currentGalleryData;
    if (!gallery) {
        alert('Gallery data not loaded. Please refresh the page.');
        return;
    }

    // Check if there are photos to notify about
    const photoCount = gallery.photo_count || 0;
    if (photoCount === 0) {
        alert('No photos in this gallery yet. Upload photos before sending a notification.');
        return;
    }

    // Check if there are clients to notify
    const clientEmails = gallery.client_emails || [];
    if (clientEmails.length === 0) {
        alert('No clients added to this gallery. Add client emails in Gallery Settings.');
        return;
    }

    // Confirm before sending
    const clientList = clientEmails.join(', ');
    const confirmed = confirm(
        `Send email notification to ${clientEmails.length} client(s)?\n\n` +
        `Recipients: ${clientList}\n\n` +
        `This will send ONE email per client notifying them about the ${photoCount} photo(s) in this gallery.\n\n` +
        `Continue?`
    );

    if (!confirmed) {
        return;
    }

    // Show loading state
    const notifyButton = document.getElementById('notifyClientsButton');
    const originalContent = notifyButton ? notifyButton.innerHTML : '';
    if (notifyButton) {
        notifyButton.style.opacity = '0.6';
        notifyButton.style.pointerEvents = 'none';
        notifyButton.querySelector('span').textContent = 'Sending...';
    }

    try {
        // Send batch notification via API
        const result = await apiRequest(`galleries/${galleryId}/notify-clients`, {
            method: 'POST'
        });

        // Show success message
        const successMsg = result.emails_failed > 0
            ? `Email sent to ${result.emails_sent} of ${result.total_clients} client(s). ${result.emails_failed} failed.`
            : `Email notification sent successfully to ${result.emails_sent} client(s)!`;

        showNotification(successMsg);

        // If some emails failed, show details
        if (result.failed_emails && result.failed_emails.length > 0) {
            setTimeout(() => {
                alert(`Failed to send to:\n${result.failed_emails.join('\n')}\n\nPlease check these email addresses in Gallery Settings.`);
            }, 1000);
        }
    } catch (error) {
        console.error('❌ Error sending batch notification:', error);

        // Check for specific error messages
        let errorMsg = 'Failed to send email notification. Please try again.';
        if (error.details && error.details.error) {
            errorMsg = error.details.error;
            if (error.details.hint) {
                errorMsg += `\n\nHint: ${error.details.hint}`;
            }
        } else if (error.message) {
            errorMsg = error.message;
        }

        alert(errorMsg);
    } finally {
        // Restore button state
        if (notifyButton) {
            notifyButton.style.opacity = '';
            notifyButton.style.pointerEvents = '';
            notifyButton.innerHTML = originalContent;
        }
    }
}

// Export to global scope
window.sendBatchEmailNotification = sendBatchEmailNotification;