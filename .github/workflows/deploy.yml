name: üöÄ Galerly CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  # ========================================
  # STAGE 1: VALIDATION & PREREQUISITES
  # ========================================
  validate-secrets:
    name: üîê Validate Secrets & Configuration
    runs-on: ubuntu-latest
    outputs:
      secrets-valid: ${{ steps.check-secrets.outputs.valid }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check Required Secrets
        id: check-secrets
        run: |
          echo "üîç Checking required secrets..."
          
          MISSING_SECRETS=""
          
          # AWS Credentials
          [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}AWS_ACCESS_KEY_ID "
          [[ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}AWS_SECRET_ACCESS_KEY "
          
          # Frontend
          [[ -z "${{ secrets.S3_BUCKET }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}S3_BUCKET "
          [[ -z "${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}CLOUDFRONT_DISTRIBUTION_ID "
          [[ -z "${{ secrets.FRONTEND_URL }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}FRONTEND_URL "
          
          # Backend
          [[ -z "${{ secrets.LAMBDA_FUNCTION_NAME }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}LAMBDA_FUNCTION_NAME "
          
          # DynamoDB
          [[ -z "${{ secrets.DYNAMODB_TABLE_USERS }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}DYNAMODB_TABLE_USERS "
          [[ -z "${{ secrets.DYNAMODB_TABLE_GALLERIES }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}DYNAMODB_TABLE_GALLERIES "
          [[ -z "${{ secrets.DYNAMODB_TABLE_PHOTOS }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}DYNAMODB_TABLE_PHOTOS "
          [[ -z "${{ secrets.DYNAMODB_TABLE_SESSIONS }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}DYNAMODB_TABLE_SESSIONS "
          [[ -z "${{ secrets.DYNAMODB_TABLE_SUBSCRIPTIONS }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}DYNAMODB_TABLE_SUBSCRIPTIONS "
          [[ -z "${{ secrets.DYNAMODB_TABLE_BILLING }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}DYNAMODB_TABLE_BILLING "
          
          # S3 Storage
          [[ -z "${{ secrets.S3_PHOTOS_BUCKET }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}S3_PHOTOS_BUCKET "
          
          # Stripe
          [[ -z "${{ secrets.STRIPE_SECRET_KEY }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}STRIPE_SECRET_KEY "
          [[ -z "${{ secrets.STRIPE_WEBHOOK_SECRET }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}STRIPE_WEBHOOK_SECRET "
          [[ -z "${{ secrets.STRIPE_PRICE_PLUS }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}STRIPE_PRICE_PLUS "
          [[ -z "${{ secrets.STRIPE_PRICE_PRO }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}STRIPE_PRICE_PRO "
          
          # Email
          [[ -z "${{ secrets.SMTP_HOST }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}SMTP_HOST "
          [[ -z "${{ secrets.SMTP_PORT }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}SMTP_PORT "
          [[ -z "${{ secrets.SMTP_USER }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}SMTP_USER "
          [[ -z "${{ secrets.SMTP_PASSWORD }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}SMTP_PASSWORD "
          [[ -z "${{ secrets.FROM_EMAIL }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}FROM_EMAIL "
          
          # CloudFront CDN
          [[ -z "${{ secrets.CDN_DOMAIN }}" ]] && MISSING_SECRETS="${MISSING_SECRETS}CDN_DOMAIN "
          
          if [ -n "$MISSING_SECRETS" ]; then
            echo "‚ùå Missing required secrets: $MISSING_SECRETS"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "‚úÖ All required secrets are present"
            echo "valid=true" >> $GITHUB_OUTPUT
          fi

  # ========================================
  # STAGE 2: CODE QUALITY & LINTING
  # ========================================
  lint-and-validate:
    name: üîç Code Quality & Validation
    runs-on: ubuntu-latest
    needs: validate-secrets
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install Python dependencies
        run: |
          echo "üì¶ Installing Python dependencies..."
          cd backend
          pip install -r requirements.txt
          pip install pylint flake8 pytest
          echo "‚úÖ Dependencies installed"

      - name: Lint Python code
        run: |
          echo "üîç Linting Python code..."
          cd backend
          
          # Run flake8 ONLY on application code (exclude dependencies)
          # Ignore: layer-package/, package/, python/, venv/, node_modules/
          flake8 . \
            --count \
            --select=E9,F63,F7,F82 \
            --show-source \
            --statistics \
            --exclude=layer-package,package,python,venv,node_modules,__pycache__,.git
          
          flake8 . \
            --count \
            --exit-zero \
            --max-line-length=120 \
            --statistics \
            --exclude=layer-package,package,python,venv,node_modules,__pycache__,.git
          
          echo "‚úÖ Python linting complete"

      - name: Validate Python syntax
        run: |
          echo "üîç Validating Python syntax..."
          cd backend
          python -m py_compile api.py
          python -m py_compile handlers/*.py
          python -m py_compile utils/*.py
          echo "‚úÖ Python syntax valid"

      - name: Check imports
        env: ${{ secrets }}
        run: |
          echo "üîç Checking Python imports..."
          cd backend
          python -c "
          import sys
          sys.path.insert(0, '.')
          
          # Test critical imports
          try:
              from handlers import auth_handler, gallery_handler, photo_handler
              from utils import auth, email, response, security
              print('‚úÖ All critical imports successful')
          except ImportError as e:
              print(f'‚ùå Import failed: {e}')
              sys.exit(1)
          "

      - name: Validate frontend structure
        run: |
          echo "üîç Validating frontend structure..."
          
          # Check required HTML files
          REQUIRED_HTML="index.html auth.html dashboard.html gallery.html client-gallery.html"
          for file in $REQUIRED_HTML; do
            if [ ! -f "frontend/$file" ]; then
              echo "‚ùå Missing required file: $file"
              exit 1
            fi
          done
          
          # Check required JS files
          REQUIRED_JS="config.js auth.js gallery.js"
          for file in $REQUIRED_JS; do
            if [ ! -f "frontend/js/$file" ]; then
              echo "‚ùå Missing required file: js/$file"
              exit 1
            fi
          done
          
          # Check required CSS files
          if [ ! -f "frontend/css/style.css" ]; then
            echo "‚ùå Missing required file: css/style.css"
            exit 1
          fi
          
          echo "‚úÖ Frontend structure valid"

  # ========================================
  # STAGE 3: AWS INFRASTRUCTURE SETUP & TESTS
  # ========================================
  setup-aws-infrastructure:
    name: ‚öôÔ∏è  Setup AWS Infrastructure
    runs-on: ubuntu-latest
    needs: [validate-secrets, lint-and-validate]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install Python dependencies
        run: |
          cd backend
          pip install boto3

      - name: Create DynamoDB Tables if Missing
        run: |
          echo "üóÑÔ∏è  Checking and creating DynamoDB tables..."
          cd backend
          python setup_dynamodb.py create
          echo "‚úÖ DynamoDB setup complete"

      - name: Configure S3 Buckets if Missing
        run: |
          echo "ü™£ Checking S3 buckets..."
          
          # Check and create frontend bucket
          if ! aws s3 ls s3://${{ secrets.S3_BUCKET }} >/dev/null 2>&1; then
            echo "üì¶ Creating frontend S3 bucket: ${{ secrets.S3_BUCKET }}"
            aws s3 mb s3://${{ secrets.S3_BUCKET }} --region ${{ env.AWS_REGION }}
            
            # Configure as static website
            aws s3 website s3://${{ secrets.S3_BUCKET }} \
              --index-document index.html \
              --error-document 404.html
            
            # Set public read policy for static website
            cat > /tmp/bucket-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [{
              "Sid": "PublicReadGetObject",
              "Effect": "Allow",
              "Principal": "*",
              "Action": "s3:GetObject",
              "Resource": "arn:aws:s3:::${{ secrets.S3_BUCKET }}/*"
            }]
          }
          EOF
            aws s3api put-bucket-policy \
              --bucket ${{ secrets.S3_BUCKET }} \
              --policy file:///tmp/bucket-policy.json
            
            echo "‚úÖ Frontend bucket created and configured"
          else
            echo "‚úÖ Frontend bucket exists: ${{ secrets.S3_BUCKET }}"
          fi
          
          # Check and create photos bucket
          if ! aws s3 ls s3://${{ secrets.S3_PHOTOS_BUCKET }} >/dev/null 2>&1; then
            echo "üì¶ Creating photos S3 bucket: ${{ secrets.S3_PHOTOS_BUCKET }}"
            aws s3 mb s3://${{ secrets.S3_PHOTOS_BUCKET }} --region ${{ env.AWS_REGION }}
            
            # Block public access (photos are private by default)
            aws s3api put-public-access-block \
              --bucket ${{ secrets.S3_PHOTOS_BUCKET }} \
              --public-access-block-configuration \
                "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=false,RestrictPublicBuckets=false"
            
            echo "‚úÖ Photos bucket created"
          else
            echo "‚úÖ Photos bucket exists: ${{ secrets.S3_PHOTOS_BUCKET }}"
          fi
          
          # Configure CORS for photos bucket
          cat > /tmp/photos-cors.json << EOF
          {
            "CORSRules": [{
              "AllowedOrigins": ["${{ secrets.FRONTEND_URL }}", "http://localhost:3000"],
              "AllowedMethods": ["GET", "HEAD", "POST", "PUT"],
              "AllowedHeaders": ["*"],
              "ExposeHeaders": ["ETag", "Content-Length", "Content-Type"],
              "MaxAgeSeconds": 3600
            }]
          }
          EOF
          aws s3api put-bucket-cors \
            --bucket ${{ secrets.S3_PHOTOS_BUCKET }} \
            --cors-configuration file:///tmp/photos-cors.json
          
          echo "‚úÖ S3 buckets ready"

  test-aws-infrastructure:
    name: ‚òÅÔ∏è  Test AWS Infrastructure
    runs-on: ubuntu-latest
    needs: [setup-aws-infrastructure]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Test S3 Buckets
        run: |
          echo "ü™£ Testing S3 buckets..."
          
          # Test frontend bucket
          if aws s3 ls s3://${{ secrets.S3_BUCKET }} >/dev/null 2>&1; then
            echo "‚úÖ Frontend S3 bucket accessible: ${{ secrets.S3_BUCKET }}"
          else
            echo "‚ùå Frontend S3 bucket not accessible: ${{ secrets.S3_BUCKET }}"
            exit 1
          fi
          
          # Test photos bucket
          if aws s3 ls s3://${{ secrets.S3_PHOTOS_BUCKET }} >/dev/null 2>&1; then
            echo "‚úÖ Photos S3 bucket accessible: ${{ secrets.S3_PHOTOS_BUCKET }}"
          else
            echo "‚ùå Photos S3 bucket not accessible: ${{ secrets.S3_PHOTOS_BUCKET }}"
            exit 1
          fi

      - name: Test DynamoDB Tables
        run: |
          echo "üìä Testing DynamoDB tables..."
          
          TABLES=(
            "${{ secrets.DYNAMODB_TABLE_USERS }}"
            "${{ secrets.DYNAMODB_TABLE_GALLERIES }}"
            "${{ secrets.DYNAMODB_TABLE_PHOTOS }}"
            "${{ secrets.DYNAMODB_TABLE_SESSIONS }}"
            "${{ secrets.DYNAMODB_TABLE_SUBSCRIPTIONS }}"
            "${{ secrets.DYNAMODB_TABLE_BILLING }}"
            "${{ secrets.DYNAMODB_TABLE_REFUNDS }}"
            "${{ secrets.DYNAMODB_TABLE_AUDIT_LOG }}"
          )
          
          for table in "${TABLES[@]}"; do
            if aws dynamodb describe-table --table-name "$table" >/dev/null 2>&1; then
              echo "‚úÖ Table exists: $table"
            else
              echo "‚ùå Table not found: $table"
              exit 1
            fi
          done

      - name: Test Lambda Function
        run: |
          echo "‚ö° Testing Lambda function..."
          
          # Check if function exists
          if aws lambda get-function --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} >/dev/null 2>&1; then
            echo "‚úÖ Lambda function exists: ${{ secrets.LAMBDA_FUNCTION_NAME }}"
            
            # Get function details
            RUNTIME=$(aws lambda get-function-configuration --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} --query 'Runtime' --output text)
            MEMORY=$(aws lambda get-function-configuration --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} --query 'MemorySize' --output text)
            TIMEOUT=$(aws lambda get-function-configuration --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} --query 'Timeout' --output text)
            
            echo "  Runtime: $RUNTIME"
            echo "  Memory: ${MEMORY}MB"
            echo "  Timeout: ${TIMEOUT}s"
          else
            echo "‚ùå Lambda function not found: ${{ secrets.LAMBDA_FUNCTION_NAME }}"
            exit 1
          fi

      - name: Test CloudFront Distribution
        run: |
          echo "üåê Testing CloudFront distribution..."
          
          if aws cloudfront get-distribution --id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} >/dev/null 2>&1; then
            echo "‚úÖ CloudFront distribution exists: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"
            
            STATUS=$(aws cloudfront get-distribution --id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --query 'Distribution.Status' --output text)
            echo "  Status: $STATUS"
            
            if [ "$STATUS" != "Deployed" ]; then
              echo "‚ö†Ô∏è  Warning: Distribution status is $STATUS (expected: Deployed)"
            fi
          else
            echo "‚ùå CloudFront distribution not found: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"
            exit 1
          fi

  # ========================================
  # STAGE 4: COMPREHENSIVE TEST SUITE
  # ========================================
  test-backend:
    name: üß™ Comprehensive Test Suite
    runs-on: ubuntu-latest
    needs: [setup-aws-infrastructure]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          echo "üì¶ Installing test dependencies..."
          cd backend
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-mock moto requests
          echo "‚úÖ Dependencies installed"

      - name: Run Unit Tests
        env: ${{ secrets }}
        run: |
          echo "=========================================="
          echo "üß™ RUNNING UNIT TESTS"
          echo "=========================================="
          cd backend
          
          # Run unit tests (exclude integration tests)
          pytest tests/ -v -m "not integration and not slow" \
            --cov=handlers --cov=utils --cov=api \
            --cov-report=term-missing \
            --cov-report=html \
            --junitxml=test-results/junit.xml
          
          echo ""
          echo "‚úÖ Unit tests passed"

      - name: Run CDN Tests
        env: ${{ secrets }}
        run: |
          echo "=========================================="
          echo "üåê TESTING CDN & IMAGE URLS"
          echo "=========================================="
          cd backend
          
          # Run CDN-specific tests
          pytest tests/test_cdn.py -v
          
          echo ""
          echo "‚úÖ CDN tests passed"

      - name: Run Image Transformation Tests
        env: ${{ secrets }}
        run: |
          echo "=========================================="
          echo "üñºÔ∏è  TESTING IMAGE TRANSFORMATION"
          echo "=========================================="
          cd backend
          
          # Run image transformation tests
          pytest tests/test_image_transformation.py -v
          
          echo ""
          echo "‚úÖ Image transformation tests passed"

      - name: Run Endpoint Tests
        env: ${{ secrets }}
        run: |
          echo "=========================================="
          echo "üì° TESTING API ENDPOINTS"
          echo "=========================================="
          cd backend
          
          # Run endpoint tests
          pytest tests/test_endpoints.py -v
          
          echo ""
          echo "‚úÖ Endpoint tests passed"

      - name: Run Frontend Validation Tests
        run: |
          echo "=========================================="
          echo "üé® VALIDATING FRONTEND FILES"
          echo "=========================================="
          cd backend
          
          # Run frontend validation tests
          pytest tests/test_frontend.py -v
          
          echo ""
          echo "‚úÖ Frontend validation passed"

      - name: Test Lambda Handler Imports
        env: ${{ secrets }}
        run: |
          echo "=========================================="
          echo "üîç TESTING HANDLER IMPORTS"
          echo "=========================================="
          cd backend
          python -c "
          import sys
          sys.path.insert(0, '.')
          
          handlers_to_test = [
              'auth_handler',
              'gallery_handler',
              'photo_handler',
              'billing_handler',
              'dashboard_handler',
              'notification_handler',
              'social_handler',
              'visitor_tracking_handler',
              'client_handler',
              'photo_upload_presigned',
              'subscription_handler'
          ]
          
          failed = []
          for handler in handlers_to_test:
              try:
                  exec(f'from handlers import {handler}')
                  print(f'‚úÖ {handler} imported successfully')
              except Exception as e:
                  print(f'‚ùå {handler} import failed: {e}')
                  failed.append(handler)
          
          if failed:
              print(f'\\n‚ùå Failed handlers: {failed}')
              sys.exit(1)
          else:
              print('\\n‚úÖ All handlers imported successfully')
          "
          echo ""

      - name: Run Integration Tests (Optional)
        env: ${{ secrets }}
        continue-on-error: true
        run: |
          echo "=========================================="
          echo "üîó RUNNING INTEGRATION TESTS"
          echo "=========================================="
          echo "‚ö†Ô∏è  Integration tests run against live AWS resources"
          echo "   Tests marked as 'integration' will be executed"
          echo ""
          cd backend
          
          # Run integration tests (against live AWS)
          pytest tests/ -v -m "integration" || echo "‚ö†Ô∏è  Some integration tests failed (non-blocking)"
          
          echo ""
          echo "‚úÖ Integration tests completed"

      - name: Generate Test Report
        if: always()
        run: |
          echo "=========================================="
          echo "üìä TEST SUMMARY"
          echo "=========================================="
          cd backend
          
          # Count test files
          TOTAL_TEST_FILES=$(find tests/ -name "test_*.py" | wc -l)
          echo "üìÅ Test Files: $TOTAL_TEST_FILES"
          echo ""
          
          # List all test files
          echo "üìã Test Files:"
          find tests/ -name "test_*.py" | sort | sed 's/tests\//   ‚úÖ /'
          
          echo ""
          echo "=========================================="
          echo "‚úÖ ALL TESTS COMPLETE!"
          echo "=========================================="

      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: backend/test-results/
          retention-days: 30

      - name: Upload Coverage Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: backend/htmlcov/
          retention-days: 30

  # ========================================
  # STAGE 5: DEPLOY FRONTEND
  # ========================================
  deploy-frontend:
    name: üåê Deploy Frontend
    runs-on: ubuntu-latest
    needs: [test-aws-infrastructure, test-backend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to S3
        run: |
          echo "üöÄ Deploying frontend to S3..."
          
          # Sync frontend files to S3 (deletes old files not in local)
          aws s3 sync frontend/ s3://${{ secrets.S3_BUCKET }}/ \
            --delete \
            --exclude ".git/*" \
            --exclude ".DS_Store" \
            --exclude "*.md" \
            --cache-control "public, max-age=31536000" \
            --metadata-directive REPLACE
          
          # Set proper cache control for HTML files (no cache)
          aws s3 cp frontend/ s3://${{ secrets.S3_BUCKET }}/ \
            --recursive \
            --exclude "*" \
            --include "*.html" \
            --cache-control "no-cache, no-store, must-revalidate" \
            --metadata-directive REPLACE
          
          echo "‚úÖ Frontend deployed to S3"

      - name: Update CloudFront Function
        run: |
          echo "üîß Updating CloudFront URL rewrite function..."
          
          FUNCTION_NAME="galerly-url-rewrite"
          
          if aws cloudfront describe-function --name $FUNCTION_NAME 2>/dev/null; then
            ETAG=$(aws cloudfront describe-function --name $FUNCTION_NAME --query 'ETag' --output text)
            
            aws cloudfront update-function \
              --name $FUNCTION_NAME \
              --function-code fileb://cloudfront/url-rewrite-function.js \
              --function-config Comment="URL rewrite for Galerly static site",Runtime="cloudfront-js-2.0" \
              --if-match $ETAG
            
            NEW_ETAG=$(aws cloudfront describe-function --name $FUNCTION_NAME --query 'ETag' --output text)
            aws cloudfront publish-function \
              --name $FUNCTION_NAME \
              --if-match $NEW_ETAG
            
            echo "‚úÖ CloudFront function updated"
          else
            echo "‚ö†Ô∏è  CloudFront function not found, skipping"
          fi

      - name: Invalidate CloudFront Cache
        run: |
          echo "üîÑ Invalidating CloudFront cache..."
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "‚úÖ Cache invalidation created: $INVALIDATION_ID"

  # ========================================
  # STAGE 6: DEPLOY BACKEND
  # ========================================
  deploy-backend:
    name: ‚ö° Deploy Backend
    runs-on: ubuntu-latest
    needs: [test-aws-infrastructure, test-backend]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build Lambda Layer (Image Processing)
        run: |
          echo "=========================================="
          echo "üì¶ BUILDING LAMBDA LAYER: Image Processing"
          echo "=========================================="
          cd backend
          
          # üßπ CLEAN BUILD: Remove ALL previous build artifacts
          echo "üßπ STEP 1: Cleaning ALL previous build artifacts..."
          rm -rf layer-package layer.zip
          rm -rf package lambda-deployment.zip
          rm -rf python __pycache__ *.pyc
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type f -name "*.pyo" -delete 2>/dev/null || true
          echo "‚úÖ Build environment completely cleaned"
          echo ""
          
          # Fresh start
          mkdir -p layer-package/python
          
          echo ""
          echo "üìö Installing heavy image processing dependencies..."
          echo "   - Pillow (image manipulation)"
          echo "   - rawpy (RAW format support: DNG, CR2, NEF, ARW, etc.)"
          echo "   - pillow-heif (HEIC/HEIF support for iPhone photos)"
          echo "   - numpy (required by rawpy)"
          echo ""
          
          # üîÑ FRESH INSTALL: Force reinstall all dependencies
          echo "üîÑ STEP 2: Installing dependencies from scratch..."
          pip install --upgrade pip
          pip install \
            Pillow>=10.0.0 \
            rawpy>=0.18.0 \
            pillow-heif>=0.13.0 \
            numpy \
            -t layer-package/python/ \
            --platform manylinux2014_x86_64 \
            --only-binary=:all: \
            --no-cache-dir \
            --force-reinstall
          
          echo ""
          echo "üîç Verifying layer dependencies..."
          
          # Check for Pillow
          if [ -d "layer-package/python/PIL" ]; then
            PILLOW_SIZE=$(du -sh layer-package/python/PIL | cut -f1)
            echo "‚úÖ Pillow installed ($PILLOW_SIZE)"
          else
            echo "‚ùå Pillow NOT found in layer!"
            exit 1
          fi
          
          # Check for rawpy
          if ls layer-package/python/rawpy* >/dev/null 2>&1 || [ -d "layer-package/python/rawpy" ]; then
            RAWPY_SIZE=$(du -sh layer-package/python/rawpy* 2>/dev/null | head -1 | cut -f1)
            echo "‚úÖ rawpy installed ($RAWPY_SIZE) - RAW format support"
          else
            echo "‚ùå rawpy NOT found in layer!"
            exit 1
          fi
          
          # Check for pillow-heif
          if ls layer-package/python/pillow_heif* >/dev/null 2>&1 || [ -d "layer-package/python/pillow_heif" ]; then
            HEIF_SIZE=$(du -sh layer-package/python/pillow_heif* 2>/dev/null | head -1 | cut -f1)
            echo "‚úÖ pillow-heif installed ($HEIF_SIZE) - HEIC support"
          else
            echo "‚ö†Ô∏è  pillow-heif NOT found (HEIC files may fail)"
          fi
          
          # Check for numpy
          if [ -d "layer-package/python/numpy" ]; then
            NUMPY_SIZE=$(du -sh layer-package/python/numpy | cut -f1)
            echo "‚úÖ numpy installed ($NUMPY_SIZE) - required by rawpy"
          else
            echo "‚ùå numpy NOT found in layer!"
            exit 1
          fi
          
          echo ""
          echo "üßπ Cleaning up layer (removing unnecessary files)..."
          cd layer-package/python
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type f -name "*.pyo" -delete 2>/dev/null || true
          find . -type f -name "*.so" -exec strip {} \; 2>/dev/null || true
          cd ../..
          
          echo "üì¶ Creating layer zip..."
          cd layer-package
          zip -r ../layer.zip . -q
          cd ..
          
          LAYER_SIZE=$(du -h layer.zip | cut -f1)
          LAYER_SIZE_BYTES=$(stat -f%z layer.zip 2>/dev/null || stat -c%s layer.zip)
          LAYER_SIZE_MB=$((LAYER_SIZE_BYTES / 1024 / 1024))
          
          echo ""
          echo "=========================================="
          echo "‚úÖ Lambda Layer Created Successfully!"
          echo "=========================================="
          echo "üì¶ Size: $LAYER_SIZE (${LAYER_SIZE_MB}MB)"
          echo "üì∏ RAW Format Support: ENABLED"
          echo "üì± HEIC Support: ENABLED"
          echo "üî¢ NumPy Support: ENABLED"
          echo "=========================================="

      - name: Publish Lambda Layer
        id: publish-layer
        run: |
          echo "üöÄ Publishing Lambda Layer to AWS..."
          cd backend
          
          LAYER_VERSION=$(aws lambda publish-layer-version \
            --layer-name galerly-image-processing \
            --description "Image processing libraries: Pillow, rawpy (RAW), pillow-heif (HEIC), numpy" \
            --license-info "MIT" \
            --zip-file fileb://layer.zip \
            --compatible-runtimes python3.11 python3.12 \
            --region ${{ env.AWS_REGION }} \
            --query 'Version' \
            --output text)
          
          echo "‚úÖ Layer published: Version $LAYER_VERSION"
          echo "LAYER_VERSION=$LAYER_VERSION" >> $GITHUB_OUTPUT
          
          # Get Layer ARN
          LAYER_ARN=$(aws lambda list-layer-versions \
            --layer-name galerly-image-processing \
            --region ${{ env.AWS_REGION }} \
            --query 'LayerVersions[0].LayerVersionArn' \
            --output text)
          
          echo "LAYER_ARN=$LAYER_ARN" >> $GITHUB_OUTPUT
          echo "üìã Layer ARN: $LAYER_ARN"

      - name: Package Lambda Function (Lightweight)
        run: |
          echo "=========================================="
          echo "üì¶ PACKAGING LIGHTWEIGHT LAMBDA FUNCTION"
          echo "=========================================="
          cd backend
          
          # üßπ CLEAN BUILD: Ensure clean package directory
          echo "üßπ STEP 1: Cleaning package directory..."
          rm -rf package lambda-deployment.zip
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          echo "‚úÖ Package directory cleaned"
          echo ""
          
          # Fresh start
          mkdir -p package
          
          echo ""
          echo "üìö STEP 2: Installing lightweight dependencies from scratch..."
          pip install --upgrade pip
          pip install \
            boto3 \
            stripe \
            python-dotenv \
            -t package/ \
            --no-cache-dir \
            --force-reinstall
          
          echo ""
          echo "üîç Verifying lightweight dependencies..."
          
          # Check for boto3
          if [ -d "package/boto3" ]; then
            echo "‚úÖ boto3 installed (AWS SDK)"
          else
            echo "‚ùå boto3 NOT found!"
            exit 1
          fi
          
          # Check for stripe
          if [ -d "package/stripe" ]; then
            echo "‚úÖ stripe installed (Payment processing)"
          else
            echo "‚ùå stripe NOT found!"
            exit 1
          fi
          
          echo ""
          echo "üìÑ Copying application code..."
          cp -r *.py package/ 2>/dev/null || true
          cp -r handlers package/
          cp -r utils package/
          
          echo "üßπ Cleaning up..."
          cd package
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type f -name "*.pyo" -delete 2>/dev/null || true
          
          echo "üì¶ Creating deployment package..."
          zip -r ../lambda-deployment.zip . -q
          cd ..
          
          SIZE=$(du -h lambda-deployment.zip | cut -f1)
          SIZE_BYTES=$(stat -f%z lambda-deployment.zip 2>/dev/null || stat -c%s lambda-deployment.zip)
          SIZE_MB=$((SIZE_BYTES / 1024 / 1024))
          
          echo ""
          echo "=========================================="
          echo "‚úÖ Lightweight Lambda Package Created!"
          echo "=========================================="
          echo "üì¶ Size: $SIZE (${SIZE_MB}MB)"
          echo "‚ö° Fast future deployments (no heavy libs)"
          echo "üîó Uses Layer for image processing"
          echo "=========================================="

      - name: Deploy to Lambda
        run: |
          echo "üöÄ Deploying lightweight Lambda function..."
          
          # Deploy the lightweight code
          aws lambda update-function-code \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --zip-file fileb://backend/lambda-deployment.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for function code update..."
          aws lambda wait function-updated \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Lambda code deployed"
          
          # Attach the image processing layer
          echo ""
          echo "üîó Attaching image processing layer..."
          LAYER_ARN="${{ steps.publish-layer.outputs.LAYER_ARN }}"
          
          aws lambda update-function-configuration \
              --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --layers "$LAYER_ARN" \
              --region ${{ env.AWS_REGION }}
          
          echo "‚è≥ Waiting for layer attachment..."
          aws lambda wait function-updated \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          echo ""
          echo "=========================================="
          echo "‚úÖ Lambda Deployment Complete!"
          echo "=========================================="
          echo "üì¶ Lightweight code: Deployed"
          echo "üîó Layer attached: $LAYER_ARN"
          echo "üì∏ RAW format support: ENABLED"
          echo "üì± HEIC support: ENABLED"
          echo "=========================================="

      - name: Sync GitHub Secrets to Lambda Environment Variables
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}
        run: |
          echo "üîÑ SYNCING GitHub Secrets to Lambda Environment Variables..."
          echo ""
          
          # STEP 1: Get current Lambda environment variables
          echo "üìã STEP 1: Reading current Lambda environment variables..."
          aws lambda get-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} > /tmp/lambda-config.json
          
          CURRENT_VAR_COUNT=$(cat /tmp/lambda-config.json | jq -r '.Environment.Variables // {} | length')
          echo "   Found $CURRENT_VAR_COUNT existing variables in Lambda"
          
          if [ "$CURRENT_VAR_COUNT" -gt 0 ]; then
            echo "   Current Lambda variables:"
          cat /tmp/lambda-config.json | jq -r '.Environment.Variables // {} | keys[]' | while read key; do
              echo "      üóëÔ∏è  $key (will be removed)"
          done
          fi
          
          # STEP 2: FORCE CLEAR ALL Lambda environment variables
          echo ""
          echo "üßπ STEP 2: FORCE REMOVING ALL Lambda environment variables..."
          aws lambda update-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --environment '{"Variables":{}}' \
            --region ${{ env.AWS_REGION }} > /dev/null
          
          echo "‚è≥ Waiting for Lambda to update after clearing..."
          aws lambda wait function-updated \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          # STEP 2.5: VERIFY variables are truly cleared
          echo ""
          echo "üîç STEP 2.5: Verifying all variables were cleared..."
          aws lambda get-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} > /tmp/lambda-config-cleared.json
          
          CLEARED_VAR_COUNT=$(cat /tmp/lambda-config-cleared.json | jq -r '.Environment.Variables // {} | length')
          if [ "$CLEARED_VAR_COUNT" -eq 0 ]; then
            echo "‚úÖ All Lambda environment variables CLEARED (count: 0)"
          else
            echo "‚ùå Failed to clear all variables! Still have $CLEARED_VAR_COUNT variables:"
            cat /tmp/lambda-config-cleared.json | jq -r '.Environment.Variables // {} | keys[]'
            exit 1
          fi

          # STEP 3: Build new environment variables from GitHub Secrets
          echo ""
          echo "üì¶ STEP 3: Building new environment variables from GitHub Secrets..."
          
          # Parse secrets and filter out GitHub internal secrets and AWS credentials
          echo "$SECRETS_JSON" | jq -r 'to_entries[] | select(
            .key | test("^GITHUB_") | not
          ) | select(
            .key | test("^AWS_ACCESS_KEY_ID$|^AWS_SECRET_ACCESS_KEY$") | not
          ) | {(.key): .value}' | jq -s 'add' > /tmp/lambda-env-vars.json
          
          NEW_VAR_COUNT=$(cat /tmp/lambda-env-vars.json | jq 'length')
          echo "   Prepared $NEW_VAR_COUNT variables from GitHub Secrets"
          echo ""
          echo "   Variables to upload:"
          cat /tmp/lambda-env-vars.json | jq -r 'keys[]' | sort | while read key; do
            echo "      ‚úÖ $key"
          done
          
          # STEP 4: Upload ALL new variables to Lambda
          echo ""
          echo "üöÄ STEP 4: Uploading ALL GitHub Secrets to Lambda..."
          
          # Build final JSON structure
          echo "{\"Variables\":" > /tmp/lambda-env-final.json
          cat /tmp/lambda-env-vars.json >> /tmp/lambda-env-final.json
          echo "}" >> /tmp/lambda-env-final.json
          
          aws lambda update-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --environment file:///tmp/lambda-env-final.json \
            --region ${{ env.AWS_REGION }} > /dev/null
          
          echo "‚è≥ Waiting for Lambda to update with new variables..."
          aws lambda wait function-updated \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }}
          
          # STEP 5: Verify the sync
          echo ""
          echo "üîç STEP 5: Verifying sync..."
          aws lambda get-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} > /tmp/lambda-config-after.json
          
          FINAL_VAR_COUNT=$(cat /tmp/lambda-config-after.json | jq -r '.Environment.Variables // {} | length')
          echo "   Lambda now has $FINAL_VAR_COUNT environment variables"
          
          if [ "$FINAL_VAR_COUNT" -eq "$NEW_VAR_COUNT" ]; then
            echo "‚úÖ Variable count matches! ($FINAL_VAR_COUNT = $NEW_VAR_COUNT)"
          else
            echo "‚ùå Variable count mismatch! Expected $NEW_VAR_COUNT but got $FINAL_VAR_COUNT"
          fi
          
          echo ""
          echo "   Final Lambda variables:"
          cat /tmp/lambda-config-after.json | jq -r '.Environment.Variables // {} | keys[]' | sort | while read key; do
            echo "      ‚úÖ $key"
          done
          
          # Cleanup
          rm -f /tmp/lambda-config.json /tmp/lambda-config-cleared.json /tmp/lambda-env-vars.json /tmp/lambda-env-final.json /tmp/lambda-config-after.json
          
          echo ""
          echo "‚úÖ‚úÖ‚úÖ SYNC COMPLETE ‚úÖ‚úÖ‚úÖ"
          echo "‚úÖ Removed: $CURRENT_VAR_COUNT old variables"
          echo "‚úÖ Uploaded: $NEW_VAR_COUNT new variables from GitHub Secrets"
          echo "‚úÖ Final count: $FINAL_VAR_COUNT variables"
          echo "‚úÖ Lambda environment variables are now EXACTLY matched with GitHub Secrets"

      - name: Verify Lambda Function
        run: |
          echo "üîç Verifying Lambda deployment..."
          
          # Get function configuration
          CONFIG=$(aws lambda get-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }})
          
          # Check runtime
          RUNTIME=$(echo $CONFIG | jq -r '.Runtime')
          if [[ "$RUNTIME" != "python3."* ]]; then
            echo "‚ùå Unexpected runtime: $RUNTIME"
            exit 1
          fi
          
          # Check state
          STATE=$(echo $CONFIG | jq -r '.State')
          if [ "$STATE" != "Active" ]; then
            echo "‚ùå Function state: $STATE (expected: Active)"
            exit 1
          fi
          
          echo "‚úÖ Lambda verification complete"
          echo "  Runtime: $RUNTIME"
          echo "  State: $STATE"

      - name: Update API Gateway CORS
        run: |
          echo "üîß Updating API Gateway CORS configuration..."
          
          cd backend
          pip install -r requirements.txt
          
          python3 setup_aws.py api-cors
          
          echo "‚úÖ API Gateway CORS updated"

      - name: Update S3 CORS for Photo Uploads
        run: |
          echo "üîß Configuring S3 CORS for photo uploads..."
          
          # Build CORS configuration dynamically with FRONTEND_URL
          cat > /tmp/s3-cors-config.json << EOF
          {
            "CORSRules": [
              {
                "AllowedOrigins": ["${{ secrets.FRONTEND_URL }}", "http://localhost:3000"],
                "AllowedMethods": ["GET", "HEAD", "POST", "PUT"],
                "AllowedHeaders": ["*"],
                "ExposeHeaders": ["ETag", "Content-Length", "Content-Type"],
                "MaxAgeSeconds": 3600
              }
            ]
          }
          EOF
          
          echo "üìÑ CORS Configuration:"
          cat /tmp/s3-cors-config.json
          echo ""
          
          # Apply CORS to S3_PHOTOS_BUCKET (from GitHub Secrets)
          echo "üìÑ Applying CORS to bucket: ${{ secrets.S3_PHOTOS_BUCKET }}..."
          aws s3api put-bucket-cors \
            --bucket "${{ secrets.S3_PHOTOS_BUCKET }}" \
            --cors-configuration file:///tmp/s3-cors-config.json \
            --region ${{ env.AWS_REGION }}
          
          # Verify configuration
          echo ""
          echo "üß™ Verifying CORS configuration..."
          aws s3api get-bucket-cors \
            --bucket "${{ secrets.S3_PHOTOS_BUCKET }}" \
            --region ${{ env.AWS_REGION }}
          
          # Cleanup
          rm -f /tmp/s3-cors-config.json
          
          echo ""
          echo "‚úÖ S3 CORS configured for bucket: ${{ secrets.S3_PHOTOS_BUCKET }}"

  # ========================================
  # STAGE 7: POST-DEPLOYMENT TESTS
  # ========================================
  test-deployment:
    name: ‚úÖ Post-Deployment Tests
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify Images Exist in S3 Bucket
        run: |
          echo "=========================================="
          echo "üì∏ VERIFYING IMAGES IN S3 BUCKET"
          echo "=========================================="
          echo ""
          echo "ü™£ Bucket: ${{ secrets.S3_PHOTOS_BUCKET }}"
          echo "üìã Listing first 20 images..."
          echo ""
          
          # Check if bucket has any images
          IMAGE_COUNT=$(aws s3 ls s3://${{ secrets.S3_PHOTOS_BUCKET }} --recursive | wc -l)
          
          if [ "$IMAGE_COUNT" -eq 0 ]; then
            echo "‚ö†Ô∏è  WARNING: No images found in S3 bucket!"
            echo "   This might be expected for a fresh deployment"
            echo "   Upload some photos through the gallery interface"
          else
            echo "‚úÖ Found $IMAGE_COUNT images in bucket"
            echo ""
            echo "üìã Recent images (first 20):"
            aws s3 ls s3://${{ secrets.S3_PHOTOS_BUCKET }} --recursive --human-readable | head -20
          fi
          
          echo ""
          echo "=========================================="

      - name: Invalidate CDN CloudFront Cache
        run: |
          echo "=========================================="
          echo "üîÑ INVALIDATING CDN CLOUDFRONT CACHE"
          echo "=========================================="
          echo ""
          echo "üåê Distribution ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"
          echo "üìã Invalidating all cached images..."
          echo ""
          
          # Get CloudFront distribution ID for CDN (if different from main frontend distribution)
          # Try to find the CDN-specific distribution by comment
          CDN_DIST_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Galerly Image CDN'].Id" \
            --output text 2>/dev/null || echo "")
          
          if [ -z "$CDN_DIST_ID" ]; then
            echo "üìå Using main CloudFront distribution for cache invalidation"
            CDN_DIST_ID="${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}"
          else
            echo "üìå Found dedicated CDN distribution: $CDN_DIST_ID"
          fi
          
          # Create cache invalidation
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id "$CDN_DIST_ID" \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo ""
          echo "‚úÖ Cache invalidation created: $INVALIDATION_ID"
          echo "‚è≥ CloudFront will serve fresh images (takes 1-2 minutes)"
          echo ""
          
          # Get invalidation status
          STATUS=$(aws cloudfront get-invalidation \
            --distribution-id "$CDN_DIST_ID" \
            --id "$INVALIDATION_ID" \
            --query 'Invalidation.Status' \
            --output text)
          
          echo "üìä Invalidation Status: $STATUS"
          echo ""
          echo "=========================================="

      - name: Test Frontend Availability
        run: |
          echo "üåê Testing frontend availability..."
          
          # Test homepage
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.FRONTEND_URL }})
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Homepage accessible (HTTP $HTTP_CODE)"
          else
            echo "‚ùå Homepage returned HTTP $HTTP_CODE"
            exit 1
          fi

      - name: Test Lambda Function
        run: |
          echo "‚ö° Testing Lambda function..."
          
          # Invoke Lambda with inline JSON payload
          # AWS CLI v2 requires --cli-binary-format to accept raw JSON
          aws lambda invoke \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --cli-binary-format raw-in-base64-out \
            --payload '{"httpMethod":"GET","path":"/v1/health"}' \
            --region ${{ env.AWS_REGION }} \
            /tmp/lambda-response.json > /tmp/invoke-result.json
          
          # Check if invocation succeeded
          STATUS_CODE=$(cat /tmp/invoke-result.json | jq -r '.StatusCode')
          if [ "$STATUS_CODE" = "200" ]; then
            echo "‚úÖ Lambda function invoked successfully"
            echo "Response: $(cat /tmp/lambda-response.json)"
          else
            echo "‚ùå Lambda invocation failed (Status: $STATUS_CODE)"
            echo "Response: $(cat /tmp/lambda-response.json)"
            exit 1
          fi

      - name: Verify CloudFront Distribution
        run: |
          echo "üåê Verifying CloudFront distribution..."
          
          STATUS=$(aws cloudfront get-distribution \
            --id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
            --query 'Distribution.Status' \
            --output text)
          
          if [ "$STATUS" = "Deployed" ]; then
            echo "‚úÖ CloudFront distribution deployed"
          else
            echo "‚ö†Ô∏è  CloudFront status: $STATUS"
          fi

      - name: Verify RAW Format Support in Lambda
        run: |
          echo "=========================================="
          echo "üì∏ Verifying Lambda Layer Configuration"
          echo "=========================================="
          echo ""
          
          # Get Lambda configuration
          aws lambda get-function-configuration \
            --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
            --region ${{ env.AWS_REGION }} > /tmp/lambda-config.json
          
          # Check layers
          LAYER_COUNT=$(cat /tmp/lambda-config.json | jq -r '.Layers // [] | length')
          
          if [ "$LAYER_COUNT" -eq 0 ]; then
            echo "‚ùå No layers attached to Lambda function!"
            echo "   RAW format support will NOT work!"
            exit 1
          fi
          
          echo "‚úÖ Lambda has $LAYER_COUNT layer(s) attached"
          echo ""
          echo "üìã Attached Layers:"
          cat /tmp/lambda-config.json | jq -r '.Layers[] | "   - \(.Arn)"'
          
          # Check if our image processing layer is attached
          if cat /tmp/lambda-config.json | jq -r '.Layers[].Arn' | grep -q "galerly-image-processing"; then
            echo ""
            echo "‚úÖ galerly-image-processing layer is attached!"
            echo "   üì∏ RAW format support: ENABLED (DNG, CR2, NEF, ARW, RAF, ORF, RW2, PEF, 3FR)"
            echo "   üì± HEIC support: ENABLED (HEIC, HEIF for iPhone)"
            echo "   üî¢ NumPy support: ENABLED"
            echo "   üñºÔ∏è  Pillow: ENABLED"
          else
            echo ""
            echo "‚ùå galerly-image-processing layer NOT found!"
            echo "   RAW format support will NOT work!"
            exit 1
          fi
          
          # Cleanup
          rm -f /tmp/lambda-config.json
          
          echo ""
          echo "=========================================="
          echo "‚úÖ Lambda Layer Verification Complete!"
          echo "=========================================="

  # ========================================
  # STAGE 8: DEPLOYMENT SUMMARY
  # ========================================
  deployment-summary:
    name: üìä Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend, test-deployment]
    if: always()
    
    steps:
      - name: Generate Summary
        run: |
          echo "========================================" >> $GITHUB_STEP_SUMMARY
          echo "# üéâ Galerly Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "========================================" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend (S3) | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend (Lambda) | ‚úÖ Deployed |" >> $GITHUB_STEP_SUMMARY
          echo "| CloudFront | ‚úÖ Updated |" >> $GITHUB_STEP_SUMMARY
          echo "| Cache | ‚úÖ Invalidated |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Image Processing Features" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Feature | Status | Formats |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| RAW Format Support | ‚úÖ Enabled | DNG, CR2, CR3, NEF, ARW, RAF, ORF, RW2, PEF, 3FR |" >> $GITHUB_STEP_SUMMARY
          echo "| HEIC Support | ‚úÖ Enabled | HEIC, HEIF (iPhone) |" >> $GITHUB_STEP_SUMMARY
          echo "| Standard Formats | ‚úÖ Enabled | JPEG, PNG, WEBP, GIF |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Scanning | ‚úÖ Enabled | Malware detection + metadata stripping |" >> $GITHUB_STEP_SUMMARY
          echo "| Quality Preservation | ‚úÖ Enabled | Quality=98 (near-lossless) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Lambda Layer Architecture" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Layer: galerly-image-processing (~34MB)**" >> $GITHUB_STEP_SUMMARY
          echo "- Pillow (image manipulation)" >> $GITHUB_STEP_SUMMARY
          echo "- rawpy (RAW format support)" >> $GITHUB_STEP_SUMMARY
          echo "- pillow-heif (HEIC/HEIF support)" >> $GITHUB_STEP_SUMMARY
          echo "- numpy (required by rawpy)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Main Function (~20MB)**" >> $GITHUB_STEP_SUMMARY
          echo "- Application code (handlers, utils, api.py)" >> $GITHUB_STEP_SUMMARY
          echo "- boto3 (AWS SDK)" >> $GITHUB_STEP_SUMMARY
          echo "- stripe (payment processing)" >> $GITHUB_STEP_SUMMARY
          echo "- python-dotenv" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Total Size: ~54MB (well under 250MB limit)**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend URL**: ${{ secrets.FRONTEND_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **S3 Bucket**: ${{ secrets.S3_BUCKET }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Lambda Function**: ${{ secrets.LAMBDA_FUNCTION_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **CloudFront ID**: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Time**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. ‚úÖ Verify frontend at: ${{ secrets.FRONTEND_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "2. üì∏ Test DNG/RAW file uploads" >> $GITHUB_STEP_SUMMARY
          echo "3. üì± Test HEIC file uploads (iPhone photos)" >> $GITHUB_STEP_SUMMARY
          echo "4. üìä Monitor CloudWatch logs for Lambda errors" >> $GITHUB_STEP_SUMMARY
          echo "5. üß™ Test critical user flows" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "========================================" >> $GITHUB_STEP_SUMMARY
